import argparse
import geopandas
import osmnx
import networkx


parser = argparse.ArgumentParser(description="Generate a schematized representation of a given crossroad.")
parser.add_argument('-i', '--i', help='input json file generated by crossroad describer', type=argparse.FileType('r'), required=True)

args = parser.parse_args()


def is_similar_edge(G, e1, e2):
    tags_e1 = G[e1[0]][e1[1]][0]
    tags_e2 = G[e2[0]][e2[1]][0]

    if not "name" in tags_e1 or not "name" in tags_e2:
        return False
    if tags_e1["name"] != tags_e2["name"]:
        return False
    return True

def find_next_edge(G, n1, n2):
    
    for n3 in G[n2]:
        if n3 != n1 and G[n2][n3][0]["type"] == "unknown":
            if is_similar_edge(G, [n1, n2], [n2, n3]):
                return n3
    
    return None

def extend_branch(G, n1, n2, first = True):
    # find next edge in the same street
    n3 = find_next_edge(G, n1, n2)
    print("next", n1, n2, n3)
    # if not found, we reverse the edge and try to build an extension from the other side
    if n3 == None:
        if first:
            print("inverse")
            extend_branch(G, n2, n1, False)
        else:
            print("finish")
    else:
        # if found, we propagate the extension
        G[n2][n3][0]["type"] = G[n1][n2][0]["type"]
        extend_branch(G, n2, n3, False)

# load geojson data from Jérémy's tool
print("Loading input geojson (" + args.i.name + ")")
cr_input = geopandas.read_file(args.i)


# load OSM data from the same crossroad (osmnx:graph)
bounds = cr_input.total_bounds
center = [(bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2]
osm_buffer_size_meters = 200
print("Loading OpenStreetMap data " + str(center))
osm_input_init = osmnx.graph.graph_from_point(center, osm_buffer_size_meters, network_type="all", retain_all=False, truncate_by_edge=True, simplify=False)
osm_input = osmnx.utils_graph.get_undirected(osm_input_init)

# label edges of the graph from cr_input
print("Label OSM network")
networkx.set_edge_attributes(osm_input, values="unknown", name="type")
networkx.set_edge_attributes(osm_input, values="created", name="type_origin")
for index, elem in cr_input.iterrows():
    if elem["type"] in ["branch", "way"]:
        ids = list(map(int, elem["id"].split(";")))
        osm_input[ids[0]][ids[1]][0]["type"] = elem["type"]
        osm_input[ids[0]][ids[1]][0]["type_origin"] = "input"


# compute for each way[type=branch] its extension

print("Extend branches")
for n1 in osm_input:
    for n2 in osm_input[n1]:
        if n1 > n2 and osm_input[n1][n2][0]["type"] == "branch" and osm_input[n1][n2][0]["type_origin"] == "input":
            extend_branch(osm_input, n1, n2)

# merge extended Jérémy's tags in osmnx:graph as tags
# TODO

# convert them in geopandas formalism
# TODO

# compute for each branch two long edges *S1* and *S2* corresponding to the sidewalks:
# TODO


# assemble sidewalks
# TODO

# compute inner region 
# TODO

# add a white space
# TODO

# build traffic islands
# TODO

# build pedestrian crossings
# TODO

