import argparse
import geopandas
import osmnx
import networkx
from shapely.geometry import Point, LineString, MultiLineString, LinearRing, Polygon
from numpy import linalg
import numpy as np
import math
import re
import shapely.ops
import matplotlib.pyplot as plt
import itertools
import copy

parser = argparse.ArgumentParser(description="Generate a schematized representation of a given crossroad.")
parser.add_argument('-i', '--i', help='input json file generated by crossroad describer', type=argparse.FileType('r'), required=True)

args = parser.parse_args()


def reverse_geom(geom):
    def _reverse(x, y, z=None):
        if z:
            return x[::-1], y[::-1], z[::-1]
        return x[::-1], y[::-1]

    return shapely.ops.transform(_reverse, geom)

class Linearization:
    
    def __init__(self, length = 30):
        self.exponential_coef = 1.2
        self.length = length
    
    def process(self, polyline):
        #polyline = convert_to_linestring(G, polybranch)

        # discretize the polybranch following a density depending on the linear coordinate
        polydisbranch = self.discretize_polyline(polyline)
        polydisbranchcoords = np.asarray(polydisbranch.coords)

        # compute a PCA and deduce a direction line
        line = self.compute_direction_line(polydisbranchcoords)

        # project last point on this line
        return LineString([polydisbranchcoords[0], Linearization.project_on_line(Point(polydisbranchcoords[-1]), line)])


    def exponential_coordinates(self, step1, length):
        result = [0, 1]
        n = 1
        while n < length:
            n *= self.exponential_coef
            result.append(n)
        return result

    def discretize_polyline(self, polyline):
        # exponential interpolation, starting from 1 meter
        return LineString([polyline.interpolate(x) for x in self.exponential_coordinates(1, polyline.length)])


    def compute_direction_line(self, polyline):
        x = [a[0] for a in polyline]
        y = [a[1] for a in polyline]
        center = Point(sum(x) / len(x), sum(y) / len(y))
        start = polyline[0]
        v = [center.x - start[0], center.y - start[1]]
        v = v / linalg.norm(v)
        return LineString([start, start + v * self.length])

    def project_on_line(point, line):
        return line.interpolate(line.project(point))


class Expander:

    def __init__(self):
        self.bid = 0


    def reset_bid(self):
        self.bid = 0


    def process(self, G, n1, n2):
        result = self.bid, self.extend_branch(G, n1, n2)
        self.bid += 1
        return result


    def process_to_linestring(self, G, n1, n2):
        bid = self.bid
        polyline = self.process(G, n1, n2)[1]
        return bid, polyline[0], Expander.convert_to_linestring(G, polyline)


    def convert_to_linestring(G, polyline):
        return LineString([Point(G.nodes[x]["x"], G.nodes[x]["y"]) for x in polyline])


    def is_turn(m, c1, c2):
        v1 = [c1["x"] - m["x"], c1["y"] - m["y"]]
        v2 = [c2["x"] - m["x"], c2["y"] - m["y"]]
        uv1 = v1 / np.linalg.norm(v1)
        uv2 = v2 / np.linalg.norm(v2)
        dp = np.dot(uv1, uv2)

        return abs(dp) < 0.5


    def is_similar_edge(G, e1, e2):
        tags_e1 = G[e1[0]][e1[1]][0]
        tags_e2 = G[e2[0]][e2[1]][0]

        if not "name" in tags_e1 or not "name" in tags_e2:
            return False
        if tags_e1["name"] != tags_e2["name"]:
            return False
        if Expander.is_turn(G.nodes[e1[0]], G.nodes[e1[1]], G.nodes[e2[1]]):
            return False
        return True


    def find_next_edge(G, n1, n2):

        for n3 in G[n2]:
            if n3 != n1 and G[n2][n3][0]["type"] == "unknown":
                if Expander.is_similar_edge(G, [n1, n2], [n2, n3]):
                    return n3

        return None


    def extend_branch(self, G, n1, n2, first = True):
        G[n1][n2][0]["branch_id"] = self.bid

        # find next edge in the same street
        n3 = Expander.find_next_edge(G, n1, n2)
        # if not found, we reverse the edge and try to build an extension from the other side
        if n3 == None:
            if first:
                return self.extend_branch(G, n2, n1, False)
            else:
                return [n1, n2]
        else:
            # if found, we propagate the extension
            G[n2][n3][0]["type"] = G[n1][n2][0]["type"]
            return [n1] + self.extend_branch(G, n2, n3, False)


class StraightWay:
    
    def __init__(self, edge, interior_node, n1, n2):
        self.edge = edge
        self.array = np.asarray(edge.coords)
        self.interior_node = interior_node
        self.n1 = n1
        self.n2 = n2
        
    def point(self, i):
        return Point(self.array[i])
    
    def get_initial_edge_id(self):
        if self.interior_node == self.n1:
            return self.get_edge_id()
        else:
            if self.interior_node != self.n2:
                print("WRONG CONFIGURATION !!!")
            return self.get_edge_id_reverse()


    def get_edge_id(self):
        return str(self.n1) + ";" + str(self.n2)


    def get_edge_id_reverse(self):
        return str(self.n2) + ";" + str(self.n1)
    

    def build_middle_line(sw1, sw2):
        e1_1 = Linearization.project_on_line(Point(sw1.array[0]), sw2.edge)
        e1_2 = Linearization.project_on_line(Point(sw1.array[1]), sw2.edge)
        e2_1 = Linearization.project_on_line(Point(sw2.array[0]), sw1.edge)
        e2_2 = Linearization.project_on_line(Point(sw2.array[1]), sw1.edge)
        
        return LineString([LineString([e1_1, e2_1]).centroid, LineString([e1_2, e2_2]).centroid])
    
    
    # basic evaluation of the width using number of lanes, and type of highway
    def evaluate_width_way(self, osm_graph):
        gEdge = osm_graph[self.n1][self.n2][0]
        if "width" in gEdge and not re.match(r'^-?\d+(?:\.\d+)$', gEdge["width"]) is None:
            return float(gEdge["width"])
        elif "lanes" in gEdge:
            nb = int(gEdge["lanes"])
        else:
            if "oneway" in gEdge and gEdge["oneway"]:
                nb = 1
            else:
                nb = 2
        
        if "highway" in gEdge:
            if gEdge["highway"] in ["motorway", "trunk"]:
                width = 3.5
            elif gEdge["highway"] in ["primary"]:
                width = 3
            elif gEdge["highway"] in ["secondary"]:
                width = 2.75
            elif gEdge["highway"] in ["service"]:
                width = 2.25
            else:
                width = 2.75
        else:
            width = 3
        
        result = 0
        if ("cycleway" in gEdge and gEdge["cycleway"] == "track") or \
            ("cycleway:left" in gEdge and gEdge["cycleway:left"] == "track") or \
            ("cycleway:right" in gEdge and gEdge["cycleway:right"] == "track"):
            nb += 1 # ~ COVID tracks
        if ("cycleway:right" in gEdge and gEdge["cycleway:right"] == "lane") or \
           ("cycleway:left" in gEdge and gEdge["cycleway:left"] == "lane"):
            result += 1 # one meter per cycle lane


        result += nb * width

        return result


class StraightSidewalk:

    def __init__(self, edge, description, same_orientation, side):
        self.edge = edge
        self.description = description
        self.same_orientation = same_orientation
        self.side = side

    def sidewalk_id(self):
        s = self.side
        if not self.same_orientation:
            s = "left" if s == "right" else "right"
        return int(self.description[s + "_sidewalk"])

    def extends(self, length = 200):
        edgecoords = np.asarray(self.edge.coords)
        x = [a[0] for a in edgecoords]
        y = [a[1] for a in edgecoords]
        center = Point(sum(x) / len(x), sum(y) / len(y))
        start = edgecoords[0]
        end = edgecoords[1]
        v = [center.x - start[0], center.y - start[1]]
        v = v / linalg.norm(v)
        return LineString([start - v * length, end + v * length])

    # compute the intersection between the two straight sidewalk lines (considering it as infinite lines)
    def get_intersection(self, sw):
        # extend both LineString
        l1 = self.extends()
        l2 = sw.extends()

        # compute intersection between them
        return l1.intersection(l2)


class TurningSidewalk:

    def __init__(self, str_sidewalks, osm_input):
        self.str_sidewalks = str_sidewalks
        
        self.osm_input = osm_input

        self.build_simple_turn()

        if self.way.is_empty or self.is_intersecting_osm():
            self.build_beveled_turn()


    def branch_names(self):
        return [x.description["name"] for x in self.str_sidewalks]
    

    def sidewalk_id(self):
        return self.str_sidewalks[0].sidewalk_id()


    def get_intersection(self):
        return self.str_sidewalks[0].get_intersection(self.str_sidewalks[1])


    def build_simple_turn(self):
        sw1 = np.asarray(self.str_sidewalks[0].edge.coords)
        sw2 = np.asarray(self.str_sidewalks[1].edge.coords)
        intersection = self.get_intersection()
        self.way = LineString([sw1[1], intersection, sw2[1]])

    def is_intersecting_osm(self):
        for n1 in self.osm_input:
            for n2 in self.osm_input[n1]:
                if TurningSidewalk.is_car_lane(self.osm_input[n1][n2][0]):
                    p1 = self.osm_input.nodes[n1]
                    p2 = self.osm_input.nodes[n2]
                    e = LineString([[p1["x"], p1["y"]], [p2["x"], p2["y"]]])
                    if not e.intersection(self.way).is_empty:
                        return True

        return False

    def build_beveled_turn(self):
        sw1 = np.asarray(self.str_sidewalks[0].edge.coords)
        sw2 = np.asarray(self.str_sidewalks[1].edge.coords)
        self.way = LineString(np.concatenate((sw1[::-1], sw2)))
        
    def is_car_lane(osm_edge):
        if not "highway" in osm_edge:
            return False
        with_cars = ["motorway", "trunk", "primary", "secondary", "tertiary", "unclassified", "residential"]
        return osm_edge["highway"] in with_cars + [ w + "_link" for w in with_cars]

    def as_array(self):
        return np.asarray(self.way.coords)

    def buffer(self, size):
        return self.way.buffer(size)


class CrossroadSchematization:


    def __init__(self, cr_input, 
                 osm_buffer_size_meters = 200, 
                 distance_kerb_footway = 0.5,
                 white_space_meter = 1.5):
        self.osm_buffer_size_meters = osm_buffer_size_meters
        self.distance_kerb_footway = distance_kerb_footway
        self.white_space_meter = white_space_meter
        self.cr_input = cr_input

        self.load_osm()
        self.label_osm_from_input()

        # TODO: if two ways are connected in the exterior side, then consider the next edge as the branch edge
        self.extend_ways()
        
        # pairing branch ways
        self.pair_ways_by_branch()

        # compute for each branch two long edges *S1* and *S2* corresponding to the sidewalks:
        self.build_sidewalks()

        # assemble sidewalks
        self.assemble_sidewalks()

        # compute inner region 
        self.build_inner_region()

        # add a white space
        self.add_white_space_inner_region()

        # build traffic islands
        # TODO

        # build pedestrian crossings
        # TODO


    def load_osm(self):
        # load OSM data from the same crossroad (osmnx:graph)
        bounds = self.cr_input.total_bounds
        center = [(bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2]

        print("Loading OpenStreetMap data " + str(center))
        osm_input_init = osmnx.graph.graph_from_point(center, 
                                                      self.osm_buffer_size_meters, 
                                                      network_type="all", 
                                                      retain_all=False, 
                                                      truncate_by_edge=True, 
                                                      simplify=False)
        # project to Lambert93 (France) for a metric approximation
        self.osm_input_oriented = osmnx.projection.project_graph(osm_input_init, to_crs = "EPSG:2154")
        # convert to undirected graph
        self.osm_input = osmnx.utils_graph.get_undirected(self.osm_input_oriented)

    def label_osm_from_input(self):
        # label edges of the graph from cr_input
        print("Label OSM network")
        networkx.set_edge_attributes(self.osm_input, values="unknown", name="type")
        networkx.set_edge_attributes(self.osm_input, values="created", name="type_origin")
        networkx.set_edge_attributes(self.osm_input, values=-1, name="branch_id")
        for index, elem in self.cr_input.iterrows():
            if elem["type"] in ["branch", "way"]:
                ids = list(map(int, elem["id"].split(";")))
                self.osm_input[ids[0]][ids[1]][0]["type"] = elem["type"]
                self.osm_input[ids[0]][ids[1]][0]["type_origin"] = "input"


    def extend_ways(self):
        lz = Linearization()
        e = Expander()
        print("Extending branches")

        # compute for each way[type=branch] its extension
        # and fit two long edges on each polyline
        self.linear_ways = {}
        for n1 in self.osm_input:
            for n2 in self.osm_input[n1]:
                if n1 > n2 and self.osm_input[n1][n2][0]["type"] == "branch" and self.osm_input[n1][n2][0]["type_origin"] == "input":
                    bid, first_id, polybranch = e.process_to_linestring(self.osm_input, n1, n2)
                    self.linear_ways[bid] = StraightWay(lz.process(polybranch), first_id, n1, n2)


    def is_initial_edge_same_orientation(self, w):
        is_w = self.cr_input["id"] == w.get_initial_edge_id()
        filtered = self.cr_input[is_w]
        return len(filtered) > 0


    def get_initial_branch_edge(self, w):
        is_w = (self.cr_input["id"] == w.get_edge_id()) | (self.cr_input["id"] == w.get_edge_id_reverse())
        filtered = self.cr_input[is_w]
        if len(filtered) > 0:
            return filtered.iloc[0, :].to_dict()
        else:
            return None


    def pair_ways_by_branch(self):
        print("Pairing ways by branch")
        self.branches = {}

        for wid in self.linear_ways:
            w = self.linear_ways[wid]
            e = self.get_initial_branch_edge(w)
            if e is not None and (e["left_sidewalk"] != "" or e["right_sidewalk"] != ""):
                bname = e["name"]
                if not bname in self.branches:
                    self.branches[bname] = []
                self.branches[bname].append((w, e))


    def build_two_sidewalks(self, way, width, 
                            oedge_left, so_left,
                            oedge_right, so_right):
        # the shift corresponds to half the width of the street
        shift = width / 2
        
        # compute the two lines (one in each side)
        return [StraightSidewalk(way.parallel_offset(shift, "left"), oedge_left, so_left, "left"), 
                StraightSidewalk(reverse_geom(way.parallel_offset(shift, "right")), oedge_right, so_right, "right")]


    def get_initial_branche_width(self, bid):
        edges = []
        distance = 0

        for wid in self.linear_ways:
            w = self.linear_ways[wid]
            e = self.get_initial_branch_edge(w)
            osm = [self.osm_input.nodes[int(x)] for x in e["id"].split(";")]
            emeters = LineString([(x["x"], x["y"]) for x in osm])
            if e["name"] == bid:
                if len(edges) != 0:
                    for ee in edges:
                        d = ee.distance(emeters)
                        if d > distance:
                            distance = d
                edges.append(emeters)


        return distance

    def build_sidewalks(self):
        print("Building sidewalks")
        self.sidewalks = {}
        
        for bid in self.branches:
            wbranches = self.branches[bid]
            if len(wbranches) == 1 and wbranches[0][1]["left_sidewalk"] != "" and wbranches[0][1]["right_sidewalk"] != "":
                width = wbranches[0][0].evaluate_width_way(self.osm_input)
                so = self.is_initial_edge_same_orientation(wbranches[0][0])
                self.sidewalks[bid] = self.build_two_sidewalks(wbranches[0][0].edge, width, 
                                                               wbranches[0][1], so,
                                                               wbranches[0][1], so)
            elif len(wbranches) == 2 and (wbranches[0][1]["left_sidewalk"] != "" or wbranches[0][1]["right_sidewalk"] != "") \
                 and (wbranches[1][1]["left_sidewalk"] != "" or wbranches[1][1]["right_sidewalk"] != ""):
                # first build a middle line
                middle_line = StraightWay.build_middle_line(wbranches[0][0], wbranches[1][0])

                # then compute width of the street
                width = wbranches[0][0].evaluate_width_way(self.osm_input) / 2 + \
                        wbranches[1][0].evaluate_width_way(self.osm_input) / 2 + \
                        self.get_initial_branche_width(bid) + 2 * self.distance_kerb_footway

                # evaluate orientation of the initial edges
                so = [self.is_initial_edge_same_orientation(wbranches[0][0]), 
                      self.is_initial_edge_same_orientation(wbranches[1][0])]
                # build two lines associated to the middle line (wrt correct direction)
                order = [0, 1]
                if not so[0]:
                    order.reverse()
                if wbranches[order[0]][1]["left_sidewalk"] == "":
                    order.reverse()
                self.sidewalks[bid] = self.build_two_sidewalks(middle_line, width,
                                                                wbranches[order[0]][1], so[order[0]],
                                                                wbranches[order[1]][1], so[order[1]])
                

            else:
                print("Not supported configuration:", len(wbranches), "sidewalk on branch", bid)

    
    def get_sidewalk_ids(self):
        result = set()
        for bid in self.sidewalks:
            for sw in self.sidewalks[bid]:
                result.add(sw.sidewalk_id())
        return list(result)


    def get_sidewalks_by_id(self, sid):
        result = []

        for bid in self.sidewalks:
            for sw in self.sidewalks[bid]:
                if sw.sidewalk_id() == sid:
                    result.append(sw)
        
        return result

    def assemble_sidewalks(self):
        print("Assembling sidewalks")
        self.cr_input.replace('', np.nan, inplace=True)
        original_sidewalks_ids = self.get_sidewalk_ids()
        
        self.merged_sidewalks = []

        for sid in original_sidewalks_ids:
            self.merged_sidewalks.append(TurningSidewalk(self.get_sidewalks_by_id(sid), self.osm_input))


    def build_inner_region(self):
        print("Building inner region")
        open_sides = copy.copy(self.merged_sidewalks)

        # order sidewalks
        final_shape = [(open_sides.pop(), True)]
        while len(open_sides) != 0:
            cid = final_shape[-1][0].branch_names()[1]
            found = False
            for i, o in enumerate(open_sides):
                if o.branch_names()[0] == cid:
                    final_shape.append((open_sides.pop(i), True))
                    found = True
                    break
                elif o.branch_names()[1] == cid:
                    final_shape.append((open_sides.pop(i), False))
                    found = True
                    break
            if not found:
                print("Error: cannot found next sidewalk")
                return
        
        # flatten list and make it as a ring
        final_shape = [x[0].as_array() if x[1] else x[0].as_array()[::-1] for x in final_shape]
        final_shape = list(itertools.chain(*[list(x) for x in final_shape]))
        final_shape.append(final_shape[0])

        self.inner_region = Polygon(final_shape)



    def add_white_space_inner_region(self):
        print("Adding white space")
        
        # compute a buffer arround each sidewalk
        # and remove these regions from the inner region
        for p in [Polygon(x.buffer(self.white_space_meter)) for x in self.merged_sidewalks]:
            self.inner_region = self.inner_region.difference(p)


    def show(self, 
             osm_graph = False,
             linear_ways = False,
             branches = False,
             simple_sidewalks = False,
             merged_sidewalks = True,
             inner_region = True):
        colors = [ 'r', 'y', 'b', 'g', 'o', 'p', 'b']

        if inner_region:
            p = geopandas.GeoSeries(self.inner_region)
            p.plot(facecolor="#DDDDDD")

        if osm_graph:
            for n1 in self.osm_input:
                for n2 in self.osm_input[n1]:
                    if TurningSidewalk.is_car_lane(self.osm_input[n1][n2][0]):
                        p1 = self.osm_input.nodes[n1]
                        p2 = self.osm_input.nodes[n2]
                        plt.plot([p1["x"], p2["x"]], [p1["y"], p2["y"]], color = "grey")


        if linear_ways:
            for geom in self.linear_ways:
                x, y = self.linear_ways[geom].edge.xy
                plt.plot(x, y, color = "gray")
                plt.plot(x[0],y[0],'ok')

        if branches:
            for geom in self.branches:
                print(len(self.branches[geom]))
                for ee in self.branches[geom]:
                    x, y = ee[0].edge.xy
                    plt.plot(x, y, color = "black")
                    plt.plot(x[0],y[0],'ok')

        if simple_sidewalks:
            for sid in self.sidewalks:
                for sw in self.sidewalks[sid]:
                    x, y = sw.edge.xy

                    plt.plot(x, y, color = colors[ sw.sidewalk_id() % len(colors)])
                    plt.plot(x[0],y[0],'ok')

        if merged_sidewalks:
            for sw in self.merged_sidewalks:
                x, y = sw.way.xy

            
                plt.plot(x, y, color = colors[ sw.sidewalk_id() % len(colors)])


        plt.show()


# load geojson data from Jérémy's tool
print("Loading input geojson (" + args.i.name + ")")
cr_input = geopandas.read_file(args.i)


crschem = CrossroadSchematization(cr_input)

crschem.show()



