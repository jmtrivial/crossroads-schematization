import argparse
import geopandas
import osmnx
import networkx
from shapely.geometry import Point, LineString, MultiLineString
from numpy import linalg
import numpy as np
import math

parser = argparse.ArgumentParser(description="Generate a schematized representation of a given crossroad.")
parser.add_argument('-i', '--i', help='input json file generated by crossroad describer', type=argparse.FileType('r'), required=True)

args = parser.parse_args()


class Linearization:
    
    def __init__(self, length = 400):
        self.exponential_coef = 1.2
        self.length = length
    
    def process(self, polyline):
        #polyline = convert_to_linestring(G, polybranch)

        # discretize the polybranch following a density depending on the linear coordinate
        polydisbranch = self.discretize_polyline(polyline)

        # compute a PCA and deduce a direction line
        line = self.compute_direction_line(polydisbranch)

        # project last point on this line
        return LineString([polydisbranch.coords[0], Linearization.project_on_line(Point(polydisbranch.coords[-1]), line)])


    def exponential_coordinates(self, step1, length):
        result = [0, 1]
        n = 1
        while n < length:
            n *= self.exponential_coef
            result.append(n)
        return result

    def discretize_polyline(self, polyline):
        # exponential interpolation, starting from 1 meter
        return LineString([polyline.interpolate(x) for x in self.exponential_coordinates(1, polyline.length)])


    def compute_direction_line(self, polyline):
        x = [a[0] for a in polyline.coords]
        y = [a[1] for a in polyline.coords]
        center = Point(sum(x) / len(x), sum(y) / len(y))
        start = Point(polyline.coords[0])
        v = [center.x - start.x, center.y - start.y]
        v = v / linalg.norm(v)
        return LineString([start, start + v * self.length])

    def project_on_line(point, line):
        return line.interpolate(line.project(point))


class Expander:

    def __init__(self):
        self.bid = 0


    def reset_bid(self):
        self.bid = 0


    def process(self, G, n1, n2):
        result = self.bid, self.extend_branch(G, n1, n2)
        self.bid += 1
        return result


    def process_to_linestring(self, G, n1, n2):
        bid = self.bid
        return bid, Expander.convert_to_linestring(G, self.process(G, n1, n2)[1])


    def convert_to_linestring(G, polyline):
        return LineString([Point(G.nodes[x]["x"], G.nodes[x]["y"]) for x in polyline])


    def is_turn(m, c1, c2):
        v1 = [c1["x"] - m["x"], c1["y"] - m["y"]]
        v2 = [c2["x"] - m["x"], c2["y"] - m["y"]]
        uv1 = v1 / np.linalg.norm(v1)
        uv2 = v2 / np.linalg.norm(v2)
        dp = np.dot(uv1, uv2)

        return abs(dp) < 0.5


    def is_similar_edge(G, e1, e2):
        tags_e1 = G[e1[0]][e1[1]][0]
        tags_e2 = G[e2[0]][e2[1]][0]

        if not "name" in tags_e1 or not "name" in tags_e2:
            return False
        if tags_e1["name"] != tags_e2["name"]:
            return False
        if Expander.is_turn(G.nodes[e1[0]], G.nodes[e1[1]], G.nodes[e2[1]]):
            return False
        return True


    def find_next_edge(G, n1, n2):

        for n3 in G[n2]:
            if n3 != n1 and G[n2][n3][0]["type"] == "unknown":
                if Expander.is_similar_edge(G, [n1, n2], [n2, n3]):
                    return n3

        return None


    def extend_branch(self, G, n1, n2, first = True):
        G[n1][n2][0]["branch_id"] = self.bid

        # find next edge in the same street
        n3 = Expander.find_next_edge(G, n1, n2)
        # if not found, we reverse the edge and try to build an extension from the other side
        if n3 == None:
            if first:
                return self.extend_branch(G, n2, n1, False)
            else:
                return [n1, n2]
        else:
            # if found, we propagate the extension
            G[n2][n3][0]["type"] = G[n1][n2][0]["type"]
            return [n1] + self.extend_branch(G, n2, n3, False)



class CrossroadSchematization:


    def __init__(self, cr_input, osm_buffer_size_meters = 200):
        self.osm_buffer_size_meters = osm_buffer_size_meters
        self.cr_input = cr_input

        self.load_osm()
        self.label_osm_from_input()

        # TODO: if two branches are connected in the exterior side, then consider the next edge as the branch edge

        self.extend_branches()


    def load_osm(self):
        # load OSM data from the same crossroad (osmnx:graph)
        bounds = self.cr_input.total_bounds
        center = [(bounds[1] + bounds[3]) / 2, (bounds[0] + bounds[2]) / 2]

        print("Loading OpenStreetMap data " + str(center))
        osm_input_init = osmnx.graph.graph_from_point(center, 
                                                      self.osm_buffer_size_meters, 
                                                      network_type="all", 
                                                      retain_all=False, 
                                                      truncate_by_edge=True, 
                                                      simplify=False)
        # project to Lambert93 (France) for a metric approximation
        osm_input = osmnx.projection.project_graph(osm_input_init, to_crs = "EPSG:2154")
        # convert to undirected graph
        self.osm_input = osmnx.utils_graph.get_undirected(osm_input)

    def label_osm_from_input(self):
        # label edges of the graph from cr_input
        print("Label OSM network")
        networkx.set_edge_attributes(self.osm_input, values="unknown", name="type")
        networkx.set_edge_attributes(self.osm_input, values="created", name="type_origin")
        networkx.set_edge_attributes(self.osm_input, values=-1, name="branch_id")
        for index, elem in self.cr_input.iterrows():
            if elem["type"] in ["branch", "way"]:
                ids = list(map(int, elem["id"].split(";")))
                self.osm_input[ids[0]][ids[1]][0]["type"] = elem["type"]
                self.osm_input[ids[0]][ids[1]][0]["type_origin"] = "input"


    def extend_branches(self):
        lz = Linearization()
        e = Expander()
        # compute for each way[type=branch] its extension
        # and fit two long edges on each polyline
        print("Extend branches")

        self.linear_branches = {}
        for n1 in self.osm_input:
            for n2 in self.osm_input[n1]:
                if n1 > n2 and self.osm_input[n1][n2][0]["type"] == "branch" and self.osm_input[n1][n2][0]["type_origin"] == "input":
                    bid, polybranch = e.process_to_linestring(self.osm_input, n1, n2)
                    self.linear_branches[bid] = lz.process(polybranch)
                    bid += 1


    def show(self):
        import matplotlib.pyplot as plt

        for geom in self.linear_branches:
            x, y = self.linear_branches[geom].xy
            plt.plot(x, y)

        plt.show()


# load geojson data from Jérémy's tool
print("Loading input geojson (" + args.i.name + ")")
cr_input = geopandas.read_file(args.i)


crschem = CrossroadSchematization(cr_input)

crschem.show()



# merge extended Jérémy's tags in osmnx:graph as tags
# TODO

# convert them in geopandas formalism
# TODO

# compute for each branch two long edges *S1* and *S2* corresponding to the sidewalks:
# TODO


# assemble sidewalks
# TODO

# compute inner region 
# TODO

# add a white space
# TODO

# build traffic islands
# TODO

# build pedestrian crossings
# TODO

